package lazabs.horn.heap

import lazabs.horn.bottomup.HornClauses
import lazabs.horn.concurrency.ParametricEncoder.{Infinite, NoSync, NoTime, System}
import lazabs.horn.concurrency.{ParametricEncoder, VerificationLoop}
import ap.types._
import ap.parser._

object Main extends App {
  val NullObjName = "NullObj"
  val ObjSort = Heap.ADTSort(0)
  val StructSSort = Heap.ADTSort(1)
  val heap = new Heap("MyHeap", "MyAddress", ObjSort, NullObjName,
    List("HeapObject", "struct_S"), List(
      (NullObjName, Heap.CtorSignature(List(), ObjSort)),
      ("WrappedInt", Heap.CtorSignature(List(("getInt", Heap.OtherSort(Sort.Integer))), ObjSort)),
      ("WrappedS", Heap.CtorSignature(List(("getS", StructSSort)), ObjSort)),
      ("struct_S", Heap.CtorSignature(List(("x", Heap.OtherSort(Sort.Integer))),
        StructSSort))))

  val wrappedInt = heap.ctrMap("WrappedInt")
  val getInt = heap.selMap("WrappedInt", "getInt")
  val wrappedS = heap.ctrMap("WrappedS")
  val getS = heap.selMap("WrappedS", "getS")
  val struct_S = heap.ctrMap("struct_S")
  val sel_Sx = heap.selMap("struct_S","x")

  println("\nProgram:")
  println("--------")
  val progList = List("  int *p = calloc(int); ", "  *p = 42; ",
    "  struct S* ps = calloc(struct S); ", "  ps->x = *p; ",
    "  assert(ps->x == 42); ", "")
  progList.foreach(println)

  import ap.parser.IExpression._
  import HornClauses._

  val I0 = new Predicate("I0", 1)
  val I1 = new Predicate("I1", 2)
  val I2 = new Predicate("I2", 2)
  val I3 = new Predicate("I3", 3)
  val I4 = new Predicate("I4", 3)
  val I5 = new Predicate("I5", 3)

  val h = new ConstantTerm("h")
  val h1 = new ConstantTerm("h'")
  val p = new ConstantTerm("p")
  val ps = new ConstantTerm("ps")
  val ar = new ConstantTerm("ar") // heap alloc res
  val o = new ConstantTerm("o") // heap object

  /*
  > C1:
> ----------------
>   I0(emptyHeap).
>   I1(newHeap(ar), newAddress(ar))    :- I0(h), alloc(h, WrappedInt(0)) = ar.
>   I2(h', p)                          :- I1(h, p), write(h, p, WrappedInt(42)) = h'.
>   I3(newHeap(ar), p, newAddress(ar)) :- I2(h, p), alloc(h, WrappedS(struct_S(0))) = ar.
>   I4(h', p, ps)                      :- I3(h, p, ps), read(h, p) = o & write(h, ps, WrappedS(struct_S(getInt(o)))) = h'.
>   I5(h, p, ps)                       :- I4(h, p, ps).
>   false                              :- I4(h, p, ps), read(h, ps) = o & x(getS(o)) != 42.

> C2:
> ----------------
>   I0(emptyHeap).
>   I1(newHeap(ar), newAddress(ar))                                 :- I0(h), alloc(h, WrappedInt(0)) = ar.
>   I2(write(h, p, WrappedInt(42)), p)                              :- I1(h, p).
>   I3(newHeap(ar), p, newAddress(ar))                              :- I2(h, p), alloc(h, WrappedS(struct_S(0))) = ar.
>   I4(write(h, ps, WrappedS(struct_S(getInt(read(h, p))))), p, ps) :- I3(h, p, ps).
>   I5(h, p, ps)                                                    :- I4(h, p, ps).
>   false                                                           :- I4(h, p, ps), x(getS(read(h, ps))) != 42.
  */

  val clauses1 = List(I0(heap.emptyHeap()) :- true,
    I1(heap.newHeap(ar), heap.newAddr(ar)) :- (I0(h), heap.alloc(h, wrappedInt(0)) === ar),
    I2(heap.write(h, p, wrappedInt(42)), p) :- I1(h, p), // C2
    //I2(h1, p) :- (I1(h, p), heap.writeFun(h, p, WrappedInt(42)) === h1), //C1
    I3(heap.newHeap(ar), p, heap.newAddr(ar)) :- (I2(h, p), heap.alloc(h, wrappedS(struct_S(0))) === ar),
    I4(heap.write(h, ps, wrappedS(struct_S(getInt(heap.read(h, p))))), p, ps) :- I3(h, p, ps), // C2
    //I4(h1, p, ps) :- (I3(h, p, ps), heap.readFun(h, p) === o, heap.writeFun(h, ps,wrappedS(struct_S(getInt(o)))) === h1), // C1
    I5(h, p, ps) :- I4(h, p, ps)
  )
  val assertions = List(
    false :- (I0(h), heap.counter(h) =/= 0), // emptyHeap = 0
    false :- (I0(h), heap.addrToNat(p) === 0, heap.isAlloc(h,p)),
    //false :- (I0(h), heap.alloc(h, wrappedInt(0)) === ar, !heap.isAlloc(heap.newHeap(ar),heap.newAddr(ar)))
    false :- (I1(h,p), heap.counter(h) =/= 1) // after 1 alloc heap = 1
    //false :- (I1(h,p), heap.addrToNat(p) =/= 42) // after 1 alloc p = 1
    //false :- (I1(h,p), !heap.isAlloc(h,p)) // <h,p> is allocated
    //false :- (I1(h,p), getInt(heap.read(h,p)) =/= 42) // 1 alloc obj was Int(0)
    //false :- (heap.counter(heap.emptyHeap())  =/= 0)
    //false :- (I4(h, p, ps), sel_Sx(getS(heap.read(h, ps))) =/= 42) // C2
    //false :- (I4(h, p, ps), heap.read(h, ps) === o, sel_Sx(getS(o)) =/= 42) // C1
  )
  println("Clauses:")
  println("--------")
  val clauseHeads = for (c <- clauses1 ++ assertions) yield (ap.DialogUtil.asString
  {PrincessLineariser printExpression c.head})
  val maxHeadLen = clauseHeads.maxBy(_.length).length
  for (c <- clauses1 ++ assertions) {
    val curHeadLen = ap.DialogUtil.asString {
      PrincessLineariser printExpression c.head}.length
    println("  " ++ c.toPrologString(maxHeadLen - curHeadLen))
  }
  println

  val process: ParametricEncoder.Process = clauses1.zip(List.fill(clauses1.length)(NoSync))

  val system = System(List((process, ParametricEncoder.Singleton)),
      0, None, NoTime, List(), assertions)
  try {
    new VerificationLoop(system)  } catch {
    case _ => {
      println()
    }
  }

}
